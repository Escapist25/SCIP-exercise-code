(define (deriv expr var) 
  ;(display expr)
  ;(newline)
  (cond ((number? expr) 0) 
        ((null? expr) 0)
        ((variable? expr) 
         (if (same-variable? expr var) 
           1
           0))
        ((not (pair? (cdr expr))) (deriv (car expr) var))
        ((sum? expr)
         (make-sum (deriv (addend expr) var) 
                   (deriv (augend expr) var)))
        ((product? expr)
         (make-sum (make-product (deriv (multiplier expr) var) (multiplicand expr) )
                   (make-product (deriv (multiplicand expr) var) (multiplier expr) )))
        (else (error "unknown expression type")))) (define (variable? x) (symbol? x))
(define (same-variable? x y)
  (and (variable? x) (variable? y) (eq? x y)))
(define (single-element? expr)
  (null? (cdr expr)))
;sum - #f   <=>   product = #t
(define (sum? expr)
  (define (iter t)
    (if (single-element? t)
      #f
      (if (eq? `+ (cadr t)) 
        #t
        (iter (cddr t)))))
  (iter expr))
;(sum? `(5 * x * 3))
(define (get-sum-part-function expr)
  (define (iter t res)
    (if (single-element? t)
      (error "not a sum")
      (if (eq? `+ (cadr t))
        (let ((p2 (cddr t)))
          (lambda (x)
            (if (= 0 x) res p2)))
        (iter (cddr t) (append res (list (cadr t) (caddr t)))))))
  (iter expr (list (car expr))))
(define (product? x) (not (sum? x)))
(define (get-product-part-function expr)
  (lambda (x) (if (= x 0) (car expr) (cddr expr))))
(define (addend x) ((get-sum-part-function x) 0))
(define (augend x) ((get-sum-part-function x) 1))
(define (multiplier x) ((get-product-part-function x) 0))
(define (multiplicand x) ((get-product-part-function x) 1))
;((get-sum-part-function `(1 + 2 + 3 * 4)) 0)
;((get-product-part-function `(1 * 2 * 3 * 4)) 1)
(define (=number? x num)
  (and (number? x) (= x num)))
(define (make-sum1 a1 a2)
  (list (list a1) `+ (list a2)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (make-sum1 a1 a2))))
(define (make-product1 a1 a2)
  (list (list a1) `* (list a2)))
(define (make-product a1 a2)
  (cond ((=number? a1 0) 0)
        ((=number? a2 0) 0)
        ((=number? a1 1) a2)
        ((=number? a2 1) a1)
        ((and (number? a1) (number? a2)) (* a1 a2))
        (else (make-product1 a1 a2))))
(deriv myexpr `x)
(define myexpr `(x + x * (x + y + 2)))
(sum? myexpr)
(variable? myexpr)
(display (make-product `(5 + 3)  `(6 * 5)))
