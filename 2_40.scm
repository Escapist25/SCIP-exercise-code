(define (accumulate op initial seq)
  (if (null? seq)
    initial
    (op (car seq)
        (accumulate op initial (cdr seq)))))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define (prime? n)
  (define (iter k n)
    (cond ((= n 1) #f)
          ((> (* k k) n) #t)
          ((= 0 (remainder n k)) #f)
          (else (iter (+ k 1) n))))
  (iter 2 n))
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
(define (make-pair-sum pair)
  (let ((a (car pair))
        (b (cadr pair)))
    (list a b (+ a b))))
(define (enumerate-interval st ed) 
  (if (> st ed)
    nil
    (cons st (enumerate-interval (+ st 1) ed))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap (lambda (i) 
                          (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1))))
                        (enumerate-interval 1 n)))))
(define (unique-pairs n)
  (flatmap append 
           (map (lambda (i) 
                  (map (lambda (j) (list j i)) (enumerate-interval 1 (- i 1))) ) 
                (enumerate-interval 1 n) )))
(prime? 4)
(prime-sum-pairs 6)
(filter prime? (enumerate-interval 1 6))
(unique-pairs 6)
(define (prime-sum-pairs1 n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))
(prime-sum-pairs1 6)
