(define (accumulate op initial seq)
  (if (null? seq)
    initial
    (op (car seq)
        (accumulate op initial (cdr seq)))))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define (enumerate-interval st ed) 
  (if (> st ed)
    nil
    (cons st (enumerate-interval (+ st 1) ed))))
(define (adjoin-position new-row k rest-of-queens) 
  (append rest-of-queens (list new-row)))
(define empty-board `())
(define (safe? k positions)
  (let ((lcol k)
        (lrow (list-ref positions (- k 1))))
    (define (iter tcol positions)
      (if (= tcol lcol) 
        #t
        (if (or (= (car positions) lrow) 
                (= (abs (- (car positions) lrow)) 
                   (- lcol tcol)))
          #f
          (iter (+ tcol 1) (cdr positions)))))
    (iter 1 positions)))
(length `(1 2 3 4))
(define (queen board-size)
  (define (queen-cols k)
    (if (= k 0)
      (list empty-board)
      (filter 
        (lambda (positions) (safe? k positions))
        (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
(list-ref `(1 2 3) 2)
(queen 8)
(length (queen 8))
